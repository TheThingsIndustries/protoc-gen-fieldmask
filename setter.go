// Copyright Â© 2019 The Things Network Foundation, The Things Industries B.V.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"log"
	"sort"
	"strings"

	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
)

const FileHeader = `// Code generated by protoc-gen-fieldmask. DO NOT EDIT.`

type unknownTypeError string

func (e unknownTypeError) Error() string {
	return fmt.Sprintf("message of proto type '%s' is unknown", string(e))
}

type unsupportedTypeError string

func (e unsupportedTypeError) Error() string {
	return fmt.Sprintf("fields of proto type '%s' are unsupported", string(e))
}

type importMap map[string]string

func (m importMap) Add(name, pkg string) error {
	if name == "" && pkg == "" {
		return nil
	}
	if name == "" {
		return fmt.Errorf("import name must be specified")
	}
	if pkg == "" {
		return fmt.Errorf("package path must be specified")
	}

	if v, ok := m[name]; ok && v != pkg {
		return fmt.Errorf("import name clash at `%s`. Imported `%s` and `%s`", name, pkg, v)
	}
	m[name] = pkg
	return nil
}

func appendPaths(ctx pgsgo.Context, paths []string, prefix string, msg pgs.Message, seen map[string]struct{}) ([]string, error) {
	if seen == nil {
		seen = map[string]struct{}{}
	}

	for _, f := range msg.Fields() {
		fp := f.Name().String()
		if f.InOneOf() {
			fp = fmt.Sprintf("%s.%s", f.OneOf().Name(), fp)
		}
		if prefix != "" {
			fp = fmt.Sprintf("%s.%s", prefix, fp)
		}

		fqn := f.FullyQualifiedName()
		if _, ok := seen[fqn]; ok {
			log.Printf("Field '%s' defined at %s:%d is recursive, stopping traversal", fp, f.File().Name(), f.SourceCodeInfo().Location().Span[0])
			return paths, nil
		}
		seen[fqn] = struct{}{}

		paths = append(paths, fp)

		if f.Type().IsRepeated() || !f.Type().IsEmbed() {
			delete(seen, fqn)
			continue
		}

		sub := f.Type().Embed()
		if !sub.BuildTarget() || len(sub.Fields()) == 0 {
			delete(seen, fqn)
			continue
		}

		var err error
		paths, err = appendPaths(ctx, paths, fp, sub, seen)
		if err != nil {
			return nil, err
		}
		delete(seen, fqn)
	}

	for _, o := range msg.OneOfs() {
		fp := o.Name().String()
		if prefix != "" {
			fp = fmt.Sprintf("%s.%s", prefix, fp)
		}
		paths = append(paths, fp)
	}
	return paths, nil
}

func buildIndented(buf *strings.Builder, tabCount uint, s string) {
	for _, l := range strings.Split(s, "\n") {
		fmt.Fprintln(buf, fmt.Sprintf("%s%s", strings.Repeat("	", int(tabCount)), l))
	}
}

func (m *SetterModule) buildSetFieldsCase(buf *strings.Builder, imports importMap, tabCount uint, subs string, f pgs.Field) error {
	m.Push(f.Name().String())
	defer m.Pop()

	buildIndented(buf, tabCount, fmt.Sprintf(`case "%s":`, f.Name()))

	goType := m.ctx.Type(f)

	dstPath := "dst"
	srcPath := "src"
	if f.InOneOf() {
		dstPath = fmt.Sprintf("%s.%s", dstPath, m.ctx.Name(f.OneOf()))

		buildIndented(buf, tabCount+1, fmt.Sprintf(`if _, ok := %s.(*%s); !ok {
	%s = &%s{}
}`,
			dstPath, m.ctx.OneofOption(f),
			dstPath, m.ctx.OneofOption(f),
		))

		dstPath = fmt.Sprintf("%s.(*%s).%s", dstPath, m.ctx.OneofOption(f), m.ctx.Name(f))
		srcPath = fmt.Sprintf("%s.Get%s()", srcPath, m.ctx.Name(f))

	} else {
		name := m.ctx.Name(f).String()
		if name == "" {
			name = goType.Value().String()
			if i := strings.LastIndex(name, "."); i > 0 {
				name = name[i+1:]
			}
		}
		dstPath = fmt.Sprintf("%s.%s", dstPath, name)
		srcPath = fmt.Sprintf("%s.%s", srcPath, name)
	}

	ft := f.Type()

	buildFinal := func(tabCount uint) error {
		buildIndented(buf, tabCount, fmt.Sprintf(`if src != nil {
	%s = %s
} else {`,
			dstPath, srcPath,
		))

		if goType.IsPointer() {
			buildIndented(buf, tabCount, fmt.Sprintf(`	%s = nil
}`,
				dstPath,
			))
			return nil
		}

		if path := m.ctx.FieldTypeImportPath(f); path != "" && path != m.ctx.ImportPath(f.Message()) {
			if err := imports.Add(m.ctx.FieldTypePackageName(f).String(), path.String()); err != nil {
				return err
			}
		}

		buildIndented(buf, tabCount, fmt.Sprintf(`	var zero %s
	%s = zero
}`,
			goType,
			dstPath,
		))
		return nil
	}

	if !ft.IsEmbed() || !ft.Embed().BuildTarget() {
		if err := imports.Add("fmt", "fmt"); err != nil {
			return err
		}
		buildIndented(buf, tabCount+1, fmt.Sprintf(`if len(%s) > 0 {
	return fmt.Errorf("'%s' has no subfields, but %%s were specified", %s)
}`,
			subs,
			f.Name(), subs,
		))
		return buildFinal(tabCount + 1)
	}

	if goType.IsPointer() {
		buildIndented(buf, tabCount+1, fmt.Sprintf(`if len(%s) > 0 {
	newDst := %s
	if newDst == nil {
		newDst = &%s{}
		%s = newDst
	}
	var newSrc %s
	if src != nil {
		newSrc = %s
	}`,
			subs,
			dstPath,
			goType.Value(),
			dstPath,
			goType,
			srcPath,
		))
	} else {
		buildIndented(buf, tabCount+1, fmt.Sprintf(`if len(%s) > 0 {
	newDst := &%s
	var newSrc *%s
	if src != nil {
		newSrc = &%s
	}`,
			subs,
			dstPath,
			goType,
			srcPath,
		))
	}

	buildIndented(buf, tabCount+1, `	if err := newDst.SetFields(newSrc, subs...); err != nil {
		return err
	}
} else {`)
	if err := buildFinal(tabCount + 2); err != nil {
		return err
	}
	buildIndented(buf, tabCount+1, `}`)
	return nil
}

func (m *SetterModule) buildMethods(buf *strings.Builder, imports importMap, msg pgs.Message) error {
	m.Push(msg.FullyQualifiedName())
	defer m.Pop()

	if err := imports.Add("fmt", "fmt"); err != nil {
		return err
	}

	mType := m.ctx.Name(msg)
	if len(msg.Fields()) == 0 {
		fmt.Fprintf(buf, `
var %sFieldPathsNested []string
var %sFieldPathsTopLevel []string

func (dst *%s) SetFields(src *%s, paths ...string) error {
	if len(paths) != 0 {
		return fmt.Errorf("message %s has no fields, but paths %%s were specified", paths)
	}
	if src != nil {
		*dst = *src
	}
	return nil
}`,
			mType,
			mType,
			mType, mType,
			mType,
		)
		return nil
	}

	nestedPaths, err := appendPaths(m.ctx, make([]string, 0, len(msg.Fields())), "", msg, nil)
	if err != nil {
		return err
	}
	sort.Strings(nestedPaths)

	topLevelPaths := make([]string, 0, len(nestedPaths))
	for _, p := range nestedPaths {
		if strings.LastIndex(p, ".") > 0 {
			continue
		}
		topLevelPaths = append(topLevelPaths, p)
	}
	sort.Strings(topLevelPaths)

	fmt.Fprintf(buf, `
var %sFieldPathsNested = []string{
	%s
}

var %sFieldPathsTopLevel = []string{
	%s
}

func (dst *%s) SetFields(src *%s, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
`,
		mType, `"`+strings.Join(nestedPaths, `",
	"`)+`",`,
		mType, `"`+strings.Join(topLevelPaths, `",
	"`)+`",`,
		mType, mType,
	)

	for _, f := range msg.NonOneOfFields() {
		if err := m.buildSetFieldsCase(buf, imports, 2, "subs", f); err != nil {
			return err
		}
	}

	for _, o := range msg.OneOfs() {
		fmt.Fprintln(buf)

		goName := m.ctx.Name(o)

		buildIndented(buf, 2, fmt.Sprintf(`case "%s":
	if len(subs) == 0 && src == nil {
		dst.%s = nil
		continue
	} else if len(subs) == 0 {
		dst.%s = src.%s
		continue
	}`,
			o.Name(),
			goName,
			goName, goName,
		))

		fmt.Fprintln(buf)

		buildIndented(buf, 3, `subPathMap := _processPaths(subs)
if len(subPathMap) > 1 {
	return fmt.Errorf("more than one field specified for oneof field '%s'", name)
}
for oneofName, oneofSubs := range subPathMap {
	switch oneofName {`)

		for _, f := range o.Fields() {
			if err := m.buildSetFieldsCase(buf, imports, 4, "oneofSubs", f); err != nil {
				return err
			}
		}

		fmt.Fprintln(buf)

		buildIndented(buf, 3, `	default:
		return fmt.Errorf("invalid oneof field: '%s.%s'", name, oneofName)
	}
}`)
	}

	fmt.Fprintf(buf, `
		default:
			return fmt.Errorf("invalid field: '%%s'", name)
		}
	}
	return nil
}`,
	)
	return nil
}

type SetterModule struct {
	*pgs.ModuleBase
	initGoContext func(ctx pgs.Parameters) pgsgo.Context
	ctx           pgsgo.Context
}

func (m *SetterModule) Name() string { return "setter" }

func (m *SetterModule) InitContext(ctx pgs.BuildContext) {
	m.ModuleBase.InitContext(ctx)
	m.ctx = m.initGoContext(ctx.Parameters())
}

func (m *SetterModule) Execute(files map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	dirs := map[pgs.FilePath]pgs.Name{}
	for _, f := range files {
		m.Push(f.Name().String())

		if len(f.Messages()) == 0 {
			m.Pop()
			continue
		}

		imports := importMap{}
		buf := &strings.Builder{}
		for _, msg := range f.AllMessages() {
			var mBufs []*strings.Builder

			mBuf := &strings.Builder{}
			if err := m.buildMethods(mBuf, imports, msg); err != nil {
				m.AddError(fmt.Errorf("failed to build methods for %s: %s", msg.Name(), err).Error())
				return m.Artifacts()
			}

			if mBuf.Len() == 0 {
				continue
			}
			mBufs = append(mBufs, mBuf)

			for _, mBuf := range mBufs {
				fmt.Fprintf(buf, `
%s`,
					mBuf.String())
			}
		}

		if buf.Len() == 0 {
			m.Pop()
			continue
		}

		dirs[m.ctx.OutputPath(f).Dir()] = m.ctx.PackageName(f)

		var importString string
		switch len(imports) {
		case 0:
		case 1:
			for name, pkg := range imports {
				importString = fmt.Sprintf(`
import %s "%s"`, name, pkg)
			}
		default:
			importLines := make([]string, 0, len(imports))
			for name, pkg := range imports {
				importLines = append(importLines, fmt.Sprintf(`	%s "%s"`, name, pkg))
			}
			sort.Slice(importLines, func(i, j int) bool {
				return strings.Fields(importLines[i])[1] < strings.Fields(importLines[j])[1]
			})
			importString = fmt.Sprintf(`
import (
%s
)`,
				strings.Join(importLines, "\n"))
		}

		m.AddGeneratorFile(m.ctx.OutputPath(f).SetExt(".fm.go").String(), fmt.Sprintf(`%s

package %s
%s%s
`,
			FileHeader,
			m.ctx.PackageName(f),
			importString,
			buf.String(),
		))
		m.Pop()
	}

	for dir, pkg := range dirs {
		m.AddGeneratorFile(dir.Push(dir.Base()).SetExt(".pb.util.fm.go").String(), fmt.Sprintf(`%s
package %s

import (
	"sort"
	"strings"
)

// _processPaths returns paths as a pathMap.
func _processPaths(paths []string) map[string][]string {
	sort.Strings(paths)

	topLevel := make(map[string]struct{}, len(paths))
	_pathMap := make(map[string]map[string]struct{}, len(paths))
	for _, p := range paths {
		if !strings.Contains(p, ".") {
			topLevel[p] = struct{}{}
			continue
		}
		parts := strings.SplitN(p, ".", 2)
		h, t := parts[0], parts[1]
		if _pathMap[h] == nil {
			_pathMap[h] = map[string]struct{}{t: {}}
		} else {
			_pathMap[h][t] = struct{}{}
		}
	}

	for f := range topLevel {
		_pathMap[f] = nil
	}

	pathMap := make(map[string][]string, len(_pathMap))
	for top, subs := range _pathMap {
		pathMap[top] = make([]string, 0, len(subs))
		for sub := range subs {
			pathMap[top] = append(pathMap[top], sub)
		}
	}
	return pathMap
}
`,
			FileHeader,
			pkg,
		))
	}
	return m.Artifacts()
}

func Setter(initGoContext func(ctx pgs.Parameters) pgsgo.Context) *SetterModule {
	return &SetterModule{
		ModuleBase:    &pgs.ModuleBase{},
		initGoContext: initGoContext,
	}
}
