// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package testdata

import fmt "fmt"

func (*Empty) FieldMaskPaths(_ bool) []string {
	return nil
}

func (dst *Empty) SetFields(src *Empty, paths ...string) error {
	if len(paths) != 0 {
		return fmt.Errorf("message Empty has no fields, but paths %s were specified", paths)
	}
	if src != nil {
		*dst = *src
	}
	return nil
}

var TestFieldPathsNested = []string{
	"a",
	"a.a",
	"a.a.a",
	"a.a.b",
	"a.a.c",
	"a.a.d",
	"a.b",
	"a.c",
	"a.d",
	"a.e",
	"b",
	"b.a",
	"b.a.a",
	"b.a.b",
	"b.a.c",
	"b.a.d",
	"b.b",
	"b.c",
	"b.d",
	"b.e",
	"c",
	"c.a",
	"c.a.a",
	"c.a.b",
	"c.a.c",
	"c.a.d",
	"c.b",
	"c.c",
	"c.d",
	"c.e",
	"g",
	"testOneof",
	"testOneof.d",
	"testOneof.e",
	"testOneof.f",
}

var TestFieldPathsTopLevel = []string{
	"a",
	"b",
	"c",
	"g",
	"testOneof",
}

func (dst *Test) SetFields(src *Test, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "a":
			if len(subs) > 0 {
				newDst := dst.A
				if newDst == nil {
					newDst = &Test_TestNested{}
					dst.A = newDst
				}
				var newSrc *Test_TestNested
				if src != nil {
					newSrc = src.A
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.A = src.A
				} else {
					dst.A = nil
				}
			}
		case "c":
			if len(subs) > 0 {
				newDst := &dst.C
				var newSrc *Test_TestNested
				if src != nil {
					newSrc = &src.C
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.C = src.C
				} else {
					var zero Test_TestNested
					dst.C = zero
				}
			}
		case "b":
			if len(subs) > 0 {
				newDst := dst.CustomName
				if newDst == nil {
					newDst = &Test_TestNested{}
					dst.CustomName = newDst
				}
				var newSrc *Test_TestNested
				if src != nil {
					newSrc = src.CustomName
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.CustomName = src.CustomName
				} else {
					dst.CustomName = nil
				}
			}
		case "g":
			if len(subs) > 0 {
				newDst := dst.G
				if newDst == nil {
					newDst = &Empty{}
					dst.G = newDst
				}
				var newSrc *Empty
				if src != nil {
					newSrc = src.G
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.G = src.G
				} else {
					dst.G = nil
				}
			}

		case "testOneof":
			if len(subs) == 0 && src == nil {
				dst.TestOneof = nil
				continue
			} else if len(subs) == 0 {
				dst.TestOneof = src.TestOneof
				continue
			}

			subPathMap := _processPaths(subs)
			if len(subPathMap) > 1 {
				return fmt.Errorf("more than one field specified for oneof field '%s'", name)
			}
			for oneofName, oneofSubs := range subPathMap {
				switch oneofName {
				case "e":
					if _, ok := dst.TestOneof.(*Test_E); !ok {
						dst.TestOneof = &Test_E{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'e' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestOneof.(*Test_E).E = src.GetE()
					} else {
						var zero uint32
						dst.TestOneof.(*Test_E).E = zero
					}
				case "d":
					if _, ok := dst.TestOneof.(*Test_D); !ok {
						dst.TestOneof = &Test_D{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'d' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestOneof.(*Test_D).D = src.GetD()
					} else {
						var zero int32
						dst.TestOneof.(*Test_D).D = zero
					}
				case "f":
					if _, ok := dst.TestOneof.(*Test_F); !ok {
						dst.TestOneof = &Test_F{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'f' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestOneof.(*Test_F).F = src.GetF()
					} else {
						var zero []byte
						dst.TestOneof.(*Test_F).F = zero
					}

				default:
					return fmt.Errorf("invalid oneof field: '%s.%s'", name, oneofName)
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var Test_TestNestedFieldPathsNested = []string{
	"a",
	"a.a",
	"a.b",
	"a.c",
	"a.d",
	"b",
	"c",
	"d",
	"e",
}

var Test_TestNestedFieldPathsTopLevel = []string{
	"a",
	"b",
	"c",
	"d",
	"e",
}

func (dst *Test_TestNested) SetFields(src *Test_TestNested, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "a":
			if len(subs) > 0 {
				newDst := dst.A
				if newDst == nil {
					newDst = &Test_TestNested_TestNestedNested{}
					dst.A = newDst
				}
				var newSrc *Test_TestNested_TestNestedNested
				if src != nil {
					newSrc = src.A
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.A = src.A
				} else {
					dst.A = nil
				}
			}
		case "b":
			if len(subs) > 0 {
				return fmt.Errorf("'b' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.B = src.B
			} else {
				var zero []byte
				dst.B = zero
			}
		case "c":
			if len(subs) > 0 {
				return fmt.Errorf("'c' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.C = src.C
			} else {
				dst.C = nil
			}
		case "d":
			if len(subs) > 0 {
				return fmt.Errorf("'d' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.D = src.D
			} else {
				dst.D = nil
			}
		case "e":
			if len(subs) > 0 {
				return fmt.Errorf("'e' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.E = src.E
			} else {
				dst.E = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var Test_TestNested_TestNestedNestedFieldPathsNested = []string{
	"a",
	"b",
	"c",
	"d",
}

var Test_TestNested_TestNestedNestedFieldPathsTopLevel = []string{
	"a",
	"b",
	"c",
	"d",
}

func (dst *Test_TestNested_TestNestedNested) SetFields(src *Test_TestNested_TestNestedNested, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "a":
			if len(subs) > 0 {
				return fmt.Errorf("'a' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.A = src.A
			} else {
				var zero int32
				dst.A = zero
			}
		case "b":
			if len(subs) > 0 {
				return fmt.Errorf("'b' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.B = src.B
			} else {
				var zero int64
				dst.B = zero
			}
		case "c":
			if len(subs) > 0 {
				return fmt.Errorf("'c' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.C = src.C
			} else {
				dst.C = nil
			}
		case "d":
			if len(subs) > 0 {
				return fmt.Errorf("'d' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.D = src.D
			} else {
				dst.D = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}
