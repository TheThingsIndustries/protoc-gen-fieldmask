// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package testdata

import (
	fmt "fmt"
	github_com_TheThingsIndustries_protoc_gen_fieldmask_testdata_testpackage "github.com/TheThingsIndustries/protoc-gen-fieldmask/testdata/testpackage"
)

var EmptyFieldPathsNested []string
var EmptyFieldPathsTopLevel []string

func (dst *Empty) SetFields(src *Empty, paths ...string) error {
	if len(paths) != 0 {
		return fmt.Errorf("message Empty has no fields, but paths %s were specified", paths)
	}
	if src != nil {
		*dst = *src
	}
	return nil
}

var TestFieldPathsNested = []string{
	"a",
	"a.a",
	"a.a.a",
	"a.a.b",
	"a.a.c",
	"a.a.d",
	"a.a.h",
	"a.a.h.nested_field",
	"a.a.testNestedNestedOneOf",
	"a.a.testNestedNestedOneOf.e",
	"a.a.testNestedNestedOneOf.f",
	"a.a.testNestedNestedOneOf.g",
	"a.b",
	"a.c",
	"a.d",
	"a.e",
	"a.f",
	"b",
	"b.a",
	"b.a.a",
	"b.a.b",
	"b.a.c",
	"b.a.d",
	"b.a.h",
	"b.a.h.nested_field",
	"b.a.testNestedNestedOneOf",
	"b.a.testNestedNestedOneOf.e",
	"b.a.testNestedNestedOneOf.f",
	"b.a.testNestedNestedOneOf.g",
	"b.b",
	"b.c",
	"b.d",
	"b.e",
	"b.f",
	"c",
	"c.a",
	"c.a.a",
	"c.a.b",
	"c.a.c",
	"c.a.d",
	"c.a.h",
	"c.a.h.nested_field",
	"c.a.testNestedNestedOneOf",
	"c.a.testNestedNestedOneOf.e",
	"c.a.testNestedNestedOneOf.f",
	"c.a.testNestedNestedOneOf.g",
	"c.b",
	"c.c",
	"c.d",
	"c.e",
	"c.f",
	"g",
	"h",
	"testOneof",
	"testOneof.d",
	"testOneof.e",
	"testOneof.f",
}

var TestFieldPathsTopLevel = []string{
	"a",
	"b",
	"c",
	"g",
	"h",
	"testOneof",
}

func (dst *Test) SetFields(src *Test, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "a":
			if len(subs) > 0 {
				newDst := dst.A
				if newDst == nil {
					newDst = &Test_TestNested{}
					dst.A = newDst
				}
				var newSrc *Test_TestNested
				if src != nil {
					newSrc = src.A
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.A = src.A
				} else {
					dst.A = nil
				}
			}
		case "c":
			if len(subs) > 0 {
				newDst := &dst.C
				var newSrc *Test_TestNested
				if src != nil {
					newSrc = &src.C
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.C = src.C
				} else {
					var zero Test_TestNested
					dst.C = zero
				}
			}
		case "b":
			if len(subs) > 0 {
				newDst := dst.CustomName
				if newDst == nil {
					newDst = &Test_TestNested{}
					dst.CustomName = newDst
				}
				var newSrc *Test_TestNested
				if src != nil {
					newSrc = src.CustomName
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.CustomName = src.CustomName
				} else {
					dst.CustomName = nil
				}
			}
		case "g":
			if len(subs) > 0 {
				newDst := dst.G
				if newDst == nil {
					newDst = &Empty{}
					dst.G = newDst
				}
				var newSrc *Empty
				if src != nil {
					newSrc = src.G
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.G = src.G
				} else {
					dst.G = nil
				}
			}
		case "h":
			if len(subs) > 0 {
				return fmt.Errorf("'h' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.H = src.H
			} else {
				dst.H = nil
			}

		case "testOneof":
			if len(subs) == 0 && src == nil {
				dst.TestOneof = nil
				continue
			} else if len(subs) == 0 {
				dst.TestOneof = src.TestOneof
				continue
			}

			subPathMap := _processPaths(subs)
			if len(subPathMap) > 1 {
				return fmt.Errorf("more than one field specified for oneof field '%s'", name)
			}
			for oneofName, oneofSubs := range subPathMap {
				switch oneofName {
				case "e":
					if _, ok := dst.TestOneof.(*Test_E); !ok {
						dst.TestOneof = &Test_E{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'e' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestOneof.(*Test_E).E = src.GetE()
					} else {
						var zero uint32
						dst.TestOneof.(*Test_E).E = zero
					}
				case "d":
					if _, ok := dst.TestOneof.(*Test_D); !ok {
						dst.TestOneof = &Test_D{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'d' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestOneof.(*Test_D).D = src.GetD()
					} else {
						var zero int32
						dst.TestOneof.(*Test_D).D = zero
					}
				case "f":
					if _, ok := dst.TestOneof.(*Test_F); !ok {
						dst.TestOneof = &Test_F{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'f' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestOneof.(*Test_F).F = src.GetF()
					} else {
						dst.TestOneof.(*Test_F).F = nil
					}

				default:
					return fmt.Errorf("invalid oneof field: '%s.%s'", name, oneofName)
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var Test_TestNestedFieldPathsNested = []string{
	"a",
	"a.a",
	"a.b",
	"a.c",
	"a.d",
	"a.h",
	"a.h.nested_field",
	"a.testNestedNestedOneOf",
	"a.testNestedNestedOneOf.e",
	"a.testNestedNestedOneOf.f",
	"a.testNestedNestedOneOf.g",
	"b",
	"c",
	"d",
	"e",
	"f",
}

var Test_TestNestedFieldPathsTopLevel = []string{
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
}

func (dst *Test_TestNested) SetFields(src *Test_TestNested, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "a":
			if len(subs) > 0 {
				newDst := dst.A
				if newDst == nil {
					newDst = &Test_TestNested_TestNestedNested{}
					dst.A = newDst
				}
				var newSrc *Test_TestNested_TestNestedNested
				if src != nil {
					newSrc = src.A
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.A = src.A
				} else {
					dst.A = nil
				}
			}
		case "b":
			if len(subs) > 0 {
				return fmt.Errorf("'b' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.B = src.B
			} else {
				dst.B = nil
			}
		case "c":
			if len(subs) > 0 {
				return fmt.Errorf("'c' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.C = src.C
			} else {
				dst.C = nil
			}
		case "d":
			if len(subs) > 0 {
				return fmt.Errorf("'d' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.D = src.D
			} else {
				dst.D = nil
			}
		case "e":
			if len(subs) > 0 {
				return fmt.Errorf("'e' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.E = src.E
			} else {
				dst.E = nil
			}
		case "f":
			if len(subs) > 0 {
				return fmt.Errorf("'f' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.F = src.F
			} else {
				var zero github_com_TheThingsIndustries_protoc_gen_fieldmask_testdata_testpackage.CustomType
				dst.F = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var Test_TestNested_TestNestedNestedFieldPathsNested = []string{
	"a",
	"b",
	"c",
	"d",
	"h",
	"h.nested_field",
	"testNestedNestedOneOf",
	"testNestedNestedOneOf.e",
	"testNestedNestedOneOf.f",
	"testNestedNestedOneOf.g",
}

var Test_TestNested_TestNestedNestedFieldPathsTopLevel = []string{
	"a",
	"b",
	"c",
	"d",
	"h",
	"testNestedNestedOneOf",
}

func (dst *Test_TestNested_TestNestedNested) SetFields(src *Test_TestNested_TestNestedNested, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "a":
			if len(subs) > 0 {
				return fmt.Errorf("'a' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.A = src.A
			} else {
				var zero int32
				dst.A = zero
			}
		case "b":
			if len(subs) > 0 {
				return fmt.Errorf("'b' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.B = src.B
			} else {
				var zero int64
				dst.B = zero
			}
		case "c":
			if len(subs) > 0 {
				return fmt.Errorf("'c' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.C = src.C
			} else {
				dst.C = nil
			}
		case "d":
			if len(subs) > 0 {
				return fmt.Errorf("'d' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.D = src.D
			} else {
				dst.D = nil
			}
		case "h":
			if len(subs) > 0 {
				newDst := dst.Test_TestNested_TestNestedNested_TestNestedNestedEmbed
				if newDst == nil {
					newDst = &Test_TestNested_TestNestedNested_TestNestedNestedEmbed{}
					dst.Test_TestNested_TestNestedNested_TestNestedNestedEmbed = newDst
				}
				var newSrc *Test_TestNested_TestNestedNested_TestNestedNestedEmbed
				if src != nil {
					newSrc = src.Test_TestNested_TestNestedNested_TestNestedNestedEmbed
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Test_TestNested_TestNestedNested_TestNestedNestedEmbed = src.Test_TestNested_TestNestedNested_TestNestedNestedEmbed
				} else {
					dst.Test_TestNested_TestNestedNested_TestNestedNestedEmbed = nil
				}
			}

		case "testNestedNestedOneOf":
			if len(subs) == 0 && src == nil {
				dst.TestNestedNestedOneOf = nil
				continue
			} else if len(subs) == 0 {
				dst.TestNestedNestedOneOf = src.TestNestedNestedOneOf
				continue
			}

			subPathMap := _processPaths(subs)
			if len(subPathMap) > 1 {
				return fmt.Errorf("more than one field specified for oneof field '%s'", name)
			}
			for oneofName, oneofSubs := range subPathMap {
				switch oneofName {
				case "e":
					if _, ok := dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_E); !ok {
						dst.TestNestedNestedOneOf = &Test_TestNested_TestNestedNested_E{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_E).E
						if newDst == nil {
							newDst = &Empty{}
							dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_E).E = newDst
						}
						var newSrc *Empty
						if src != nil {
							newSrc = src.GetE()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_E).E = src.GetE()
						} else {
							dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_E).E = nil
						}
					}
				case "f":
					if _, ok := dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_F); !ok {
						dst.TestNestedNestedOneOf = &Test_TestNested_TestNestedNested_F{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'f' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_F).F = src.GetF()
					} else {
						var zero uint32
						dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_F).F = zero
					}
				case "g":
					if _, ok := dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_G); !ok {
						dst.TestNestedNestedOneOf = &Test_TestNested_TestNestedNested_G{}
					}
					if len(oneofSubs) > 0 {
						return fmt.Errorf("'g' has no subfields, but %s were specified", oneofSubs)
					}
					if src != nil {
						dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_G).G = src.GetG()
					} else {
						dst.TestNestedNestedOneOf.(*Test_TestNested_TestNestedNested_G).G = nil
					}

				default:
					return fmt.Errorf("invalid oneof field: '%s.%s'", name, oneofName)
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var Test_TestNested_TestNestedNested_TestNestedNestedEmbedFieldPathsNested = []string{
	"nested_field",
}

var Test_TestNested_TestNestedNested_TestNestedNestedEmbedFieldPathsTopLevel = []string{
	"nested_field",
}

func (dst *Test_TestNested_TestNestedNested_TestNestedNestedEmbed) SetFields(src *Test_TestNested_TestNestedNested_TestNestedNestedEmbed, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "nested_field":
			if len(subs) > 0 {
				return fmt.Errorf("'nested_field' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.NestedField = src.NestedField
			} else {
				var zero int32
				dst.NestedField = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}
