// Copyright Â© 2018 The Things Network Foundation, The Things Industries B.V.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"errors"
	"fmt"
	"log"
	"path/filepath"
	"sort"
	"strings"

	_ "github.com/TheThingsIndustries/protoc-gen-fieldmask/internal/extensions"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
	plugin_go "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pseudomuto/protokit"
)

const FileHeader = `// Code generated by protoc-gen-fieldmask. DO NOT EDIT.`

const (
	protoAnyType       = ".google.protobuf.Any"
	protoDurationType  = ".google.protobuf.Duration"
	protoFieldMaskType = ".google.protobuf.FieldMask"
	protoStructType    = ".google.protobuf.Struct"
	protoTimestampType = ".google.protobuf.Timestamp"
)

type unknownTypeError string

func (e unknownTypeError) Error() string {
	return fmt.Sprintf("message of proto type '%s' is unknown", string(e))
}

type unsupportedTypeError string

func (e unsupportedTypeError) Error() string {
	return fmt.Sprintf("fields of proto type '%s' are unsupported", string(e))
}

type recursionError struct {
	file  string
	field string
}

func (e recursionError) Error() string {
	return fmt.Sprintf("field '%s' defined at %s is recursive", e.field, e.file)
}

func appendPaths(paths []string, prefix string, md *protokit.Descriptor, mdMap map[string]*protokit.Descriptor, seen map[string]struct{}) ([]string, error) {
	if seen == nil {
		seen = map[string]struct{}{}
	}

	for _, fd := range md.GetMessageFields() {
		if _, ok := seen[fd.GetFullName()]; ok {
			return nil, recursionError{
				file:  fd.GetFile().GetName(),
				field: fd.GetFullName(),
			}
		}
		seen[fd.GetFullName()] = struct{}{}

		fp := fd.GetName()
		if prefix != "" {
			fp = fmt.Sprintf("%s.%s", prefix, fp)
		}
		paths = append(paths, fp)

		if fd.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED || fd.GetType() != descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			delete(seen, fd.GetFullName())
			continue
		}

		fmd, ok := mdMap[fd.GetTypeName()]
		if !ok {
			switch fd.GetTypeName() {
			case protoTimestampType, protoFieldMaskType, protoDurationType, protoStructType, protoAnyType:
				delete(seen, fd.GetFullName())
				continue
			}
			return nil, unknownTypeError(fd.GetTypeName())
		}

		if len(fmd.GetMessageFields()) == 0 {
			delete(seen, fd.GetFullName())
			continue
		}

		var err error
		paths, err = appendPaths(paths, fp, fmd, mdMap, seen)
		if err != nil {
			return nil, err
		}
		delete(seen, fd.GetFullName())
	}
	return paths, nil
}

func fieldTypeName(fd *protokit.FieldDescriptor) (goType string) {
	goType = fd.GetTypeName()
	if i := strings.LastIndex(goType, "."); i > 0 {
		goType = goType[i+1:]
	}

	protoType := fd.GetTypeName()[1:]

	for parent := fd.GetMessage(); parent != nil; parent = parent.GetParent() {
		for _, smd := range parent.GetMessages() {
			if protoType == smd.GetFullName() {
				goType = fmt.Sprintf("%s_%s", parent.GetName(), goType)
				if i := strings.LastIndex(goType, "."); i > 0 {
					goType = goType[i+1:]
				}
				protoType = parent.GetFullName()
			}
		}
	}
	return goType
}

func enumTypeName(fd *protokit.FieldDescriptor) (goType string) {
	goType = fd.GetTypeName()
	if i := strings.LastIndex(goType, "."); i > 0 {
		goType = goType[i+1:]
	}

	protoType := fd.GetTypeName()[1:]

	for parent := fd.GetMessage(); parent != nil; parent = parent.GetParent() {
		for _, sed := range parent.GetEnums() {
			if protoType == sed.GetFullName() {
				goType = fmt.Sprintf("%s_%s", parent.GetName(), goType)
				if i := strings.LastIndex(goType, "."); i > 0 {
					goType = goType[i+1:]
				}
				protoType = parent.GetFullName()
			}
		}
	}
	return goType
}

func buildMethod(buf *strings.Builder, md *protokit.Descriptor, paths []string, goType string, isSet bool) (map[string]string, error) {
	methName := "GetFields"
	if isSet {
		methName = "SetFields"
	}

	fmt.Fprintf(buf, `
func (dst *%s) %s(src *%s, paths ...string) error {`,
		goType, methName, goType,
	)

	if isSet {
		fmt.Fprintf(buf, `
	if src == nil {
		return fmt.Errorf("source is nil")
	}`,
		)
	}

	fmt.Fprintf(buf, `
	for _, path := range _cleanPaths(paths) {
		switch path {`,
	)

	for _, p := range paths {
		fmt.Fprintf(buf, `
		case "%s":`,
			p)

		srcPath := "src"
		dstPath := "dst"

		if sp := strings.Split(p, "."); len(sp) > 1 {
			fd := md.GetMessageField(sp[0])
			if fd.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				panic(errors.New("fieldmask for repeated field generated"))
			}

			goType := fieldTypeName(fd)

			goName := generator.CamelCase(fd.GetName())
			if v, ok := fd.OptionExtensions["gogoproto.customname"].(*string); ok {
				goName = *v
			}
			if v, ok := fd.OptionExtensions["gogoproto.embed"].(*bool); ok && *v {
				goName = goType
			}

			if fd.OneofIndex != nil {
				oneOfType := fmt.Sprintf("%s_%s", md.GetName(), goName)
				if md.GetMessage(goName) != nil {
					oneOfType = fmt.Sprintf("%s_", oneOfType)
				}
				oneOfName := generator.CamelCase(md.GetOneofDecl()[fd.GetOneofIndex()].GetName())

				dstPath = fmt.Sprintf("%s.%s", dstPath, oneOfName)

				if !isSet {
					fmt.Fprintf(buf, `
			if src == nil {
				%s = nil
				continue
			}`,
						dstPath,
					)
				}
				fmt.Fprintf(buf, `
			if %s == nil {
				%s = &%s{}
			}`,
					dstPath,
					dstPath, oneOfType,
				)

				srcPath = fmt.Sprintf("%s.Get%s()", srcPath, goName)
				dstPath = fmt.Sprintf("%s.(*%s).%s", dstPath, oneOfType, goName)
			} else {
				srcPath = fmt.Sprintf("%s.%s", srcPath, goName)
				dstPath = fmt.Sprintf("%s.%s", dstPath, goName)
			}

			if v, ok := fd.OptionExtensions["gogoproto.nullable"].(*bool); ok && !*v {
				fmt.Fprintf(buf, `
			if err := %s.%s(&%s, _pathsWithoutPrefix("%s", paths)...); err != nil {
				return fmt.Errorf("field mask '%s' could not be applied: %%s", err)
			}`,
					dstPath, methName, srcPath, sp[0],
					p,
				)

			} else {
				if !isSet && fd.OneofIndex == nil {
					fmt.Fprintf(buf, `
			if src == nil {
				%s = nil
				continue
			}`,
						dstPath,
					)
				}

				fmt.Fprintf(buf, `
			srcField := %s
			if srcField == nil {`,
					srcPath,
				)

				if isSet {
					fmt.Fprintf(buf, `
				return fmt.Errorf("field mask '%s' could not be applied: field '%s' is not set")`,
						p, sp[0],
					)
				} else {
					fmt.Fprintf(buf, `
				srcField = &%s{}`,
						goType,
					)
				}

				fmt.Fprintf(buf, `
			}
			if %s == nil {
				%s = &%s{}
			}
			if err := %s.%s(srcField, _pathsWithoutPrefix("%s", paths)...); err != nil {
				return fmt.Errorf("field mask '%s' could not be applied: %%s", err)
			}`,
					dstPath,
					dstPath, goType,
					dstPath, methName, sp[0],
					p,
				)
			}
			continue
		}

		fd := md.GetMessageField(p)

		goName := generator.CamelCase(fd.GetName())
		if v, ok := fd.OptionExtensions["gogoproto.customname"].(*string); ok {
			goName = *v
		}
		if v, ok := fd.OptionExtensions["gogoproto.embed"].(*bool); ok && *v {
			var goType string
			switch fd.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_BOOL,
				descriptor.FieldDescriptorProto_TYPE_DOUBLE,
				descriptor.FieldDescriptorProto_TYPE_FLOAT,
				descriptor.FieldDescriptorProto_TYPE_INT32,
				descriptor.FieldDescriptorProto_TYPE_SINT32,
				descriptor.FieldDescriptorProto_TYPE_SFIXED32,
				descriptor.FieldDescriptorProto_TYPE_INT64,
				descriptor.FieldDescriptorProto_TYPE_SINT64,
				descriptor.FieldDescriptorProto_TYPE_SFIXED64,
				descriptor.FieldDescriptorProto_TYPE_UINT32,
				descriptor.FieldDescriptorProto_TYPE_FIXED32,
				descriptor.FieldDescriptorProto_TYPE_UINT64,
				descriptor.FieldDescriptorProto_TYPE_FIXED64,
				descriptor.FieldDescriptorProto_TYPE_STRING,
				descriptor.FieldDescriptorProto_TYPE_BYTES:
				return nil, fmt.Errorf("invalid type specifed for embedded field `%s`: %s", p, fd.GetType())

			case descriptor.FieldDescriptorProto_TYPE_GROUP:
				return nil, unsupportedTypeError(fd.GetType().String())

			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				goType = enumTypeName(fd)

			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				goType = fd.GetTypeName()
				switch goType {
				case protoTimestampType:
					if v, ok := fd.OptionExtensions["gogoproto.stdtime"].(*bool); ok && *v {
						goType = "time.Time"
						break
					}
					return nil, unsupportedTypeError(fd.GetTypeName())

				case protoDurationType:
					if v, ok := fd.OptionExtensions["gogoproto.stdduration"].(*bool); ok && *v {
						goType = "time.Duration"
						break
					}
					return nil, unsupportedTypeError(fd.GetTypeName())

				case protoAnyType:
					goType = "types.Any"

				case protoStructType:
					goType = "types.Struct"

				case protoFieldMaskType:
					goType = "types.FieldMask"

				default:
					goType = fieldTypeName(fd)
				}

			default:
				return nil, unsupportedTypeError(fd.GetType().String())
			}

			if v, ok := fd.OptionExtensions["gogoproto.customtype"].(*string); ok {
				goType = *v
			}

			if i := strings.LastIndex(goType, "."); i >= 0 {
				goName = goType[i+1:]
			} else {
				goName = goType
			}
		}

		if fd.OneofIndex != nil {
			oneOfType := fmt.Sprintf("%s_%s", md.GetName(), goName)
			if md.GetMessage(goName) != nil {
				oneOfType = fmt.Sprintf("%s_", oneOfType)
			}
			oneOfName := generator.CamelCase(md.GetOneofDecl()[fd.GetOneofIndex()].GetName())

			srcPath = fmt.Sprintf("%s.Get%s()", srcPath, goName)
			dstPath = fmt.Sprintf("%s.%s", dstPath, oneOfName)

			fmt.Fprintf(buf, `
			if %s == nil {
				%s = &%s{}
			}`,
				dstPath,
				dstPath, oneOfType,
			)

			dstPath = fmt.Sprintf("%s.(*%s).%s", dstPath, oneOfType, goName)

		} else {
			srcPath = fmt.Sprintf("%s.%s", srcPath, goName)
			dstPath = fmt.Sprintf("%s.%s", dstPath, goName)
		}

		fmt.Fprintf(buf, `
			%s = %s`,
			dstPath, srcPath,
		)
	}
	fmt.Fprintf(buf, `
		default:
			return fmt.Errorf("invalid field path: '%%s'", path)
		}
	}
	return nil
}`,
	)
	return map[string]string{"fmt": "fmt"}, nil
}

func buildMethods(buf *strings.Builder, md *protokit.Descriptor, mdMap map[string]*protokit.Descriptor) (map[string]string, error) {
	paths, err := appendPaths(make([]string, 0, len(md.GetMessageFields())), "", md, mdMap, nil)
	if err != nil {
		// TODO: Return error here once https://github.com/TheThingsIndustries/protoc-gen-fieldmask/issues/5 is resolved.
		log.Printf("Failed to traverse `%s`: %s, skipping...", md.GetFullName(), err)
		return nil, nil
	}

	goType := md.GetName()
	for parent := md.GetParent(); parent != nil; parent = parent.GetParent() {
		goType = fmt.Sprintf("%s_%s", parent.GetName(), goType)
	}

	if len(paths) == 0 {
		fmt.Fprintf(buf, `
func (*%s) FieldMaskPaths() []string {
	return nil
}

func (dst *%s) GetFields(src *%s, paths ...string) error {
	if len(paths) != 0 {
		return fmt.Errorf("message %s has no fields, but paths %%s were specified", paths)
	}
	if src != nil {
		*dst = *src
	}
	return nil
}

func (dst *%s) SetFields(src *%s, paths ...string) error {
	if len(paths) != 0 {
		return fmt.Errorf("message %s has no fields, but paths %%s were specified", paths)
	}
	if src == nil {
		return errors.New("src is nil")
	}
	*dst = *src
	return nil
}`,
			goType,
			goType, goType,
			goType,
			goType, goType,
			goType,
		)
		return map[string]string{"errors": "errors"}, nil
	}

	sort.Strings(paths)
	fmt.Fprintf(buf, `
var _%sFieldPaths = [...]string{
	%s
}

func (*%s) FieldMaskPaths() []string {
	ret := make([]string, len(_%sFieldPaths))
	copy(ret, _%sFieldPaths[:])
	return ret
}`,
		goType, `"`+strings.Join(paths, `",
	"`)+`",`,
		goType,
		goType,
		goType,
	)

	imports, err := buildMethod(buf, md, paths, goType, false)
	if err != nil {
		return nil, err
	}

	setImports, err := buildMethod(buf, md, paths, goType, true)
	if err != nil {
		return nil, err
	}

	for name, pkg := range setImports {
		if v, ok := imports[name]; ok && v != pkg {
			return nil, fmt.Errorf("import name clash at `%s`. Imported `%s` and `%s`", name, pkg, v)
		}
		imports[name] = pkg
	}
	return imports, nil
}

func walkMessage(md *protokit.Descriptor, f func(md *protokit.Descriptor) error) error {
	if err := f(md); err != nil {
		return err
	}
	for _, smd := range md.GetMessages() {
		if err := walkMessage(smd, f); err != nil {
			return err
		}
	}
	return nil
}

func registerMessages(mdMap map[string]*protokit.Descriptor, mds ...*protokit.Descriptor) error {
	for _, md := range mds {
		if err := walkMessage(md, func(md *protokit.Descriptor) error {
			k := fmt.Sprintf(".%s", md.GetFullName())
			if _, ok := mdMap[k]; ok {
				return fmt.Errorf("message name clash at `%s`", k)
			}
			mdMap[k] = md
			return nil
		}); err != nil {
			return err
		}
	}
	return nil
}

type plugin struct{}

func (p plugin) Generate(in *plugin_go.CodeGeneratorRequest) (*plugin_go.CodeGeneratorResponse, error) {
	resp := &plugin_go.CodeGeneratorResponse{}

	fds := protokit.ParseCodeGenRequest(in)

	mdMap := map[string]*protokit.Descriptor{}
	for _, fd := range fds {
		if err := registerMessages(mdMap, fd.GetMessages()...); err != nil {
			return nil, err
		}
	}

	dirs := map[string]struct{}{}
	for _, fd := range fds {
		if len(fd.GetMessages()) == 0 {
			continue
		}

		dirName := fd.Options.GetGoPackage()
		if dirName == "" {
			dirName = filepath.Dir(fd.GetName())
		}
		fileName := filepath.Join(dirName, fmt.Sprintf("%s.pb.fm.go", strings.TrimSuffix(filepath.Base(fd.GetName()), filepath.Ext(fd.GetName()))))

		imports := map[string]string{}
		buf := &strings.Builder{}
		for _, md := range fd.GetMessages() {
			if v, ok := md.OptionExtensions["fieldmask.enable"].(*bool); ok && !*v {
				continue
			}

			var mBufs []*strings.Builder
			if err := walkMessage(md, func(md *protokit.Descriptor) error {
				if md.GetOptions().GetMapEntry() {
					return nil
				}

				mBuf := &strings.Builder{}
				mImports, err := buildMethods(mBuf, md, mdMap)
				if err != nil {
					return err
				}

				for name, pkg := range mImports {
					if v, ok := imports[name]; ok && v != pkg {
						return fmt.Errorf("import name clash at `%s`. Imported `%s` and `%s`", name, pkg, v)
					}
					imports[name] = pkg
				}

				if mBuf.Len() == 0 {
					return nil
				}
				mBufs = append(mBufs, mBuf)
				return nil
			}); err != nil {
				return nil, err
			}

			for _, mBuf := range mBufs {
				fmt.Fprintf(buf, `
%s`,
					mBuf.String())
			}
		}

		if buf.Len() == 0 {
			continue
		}

		dirs[dirName] = struct{}{}

		var importString string
		switch len(imports) {
		case 0:
		case 1:
			for name, pkg := range imports {
				importString = fmt.Sprintf(`
import %s "%s"`, name, pkg)
			}
		default:
			importLines := make([]string, 0, len(imports))
			for name, pkg := range imports {
				importLines = append(importLines, fmt.Sprintf(`	%s "%s"`, name, pkg))
			}
			sort.Slice(importLines, func(i, j int) bool {
				return strings.Fields(importLines[i])[1] < strings.Fields(importLines[j])[1]
			})
			importString = fmt.Sprintf(`
import (
%s
)`,
				strings.Join(importLines, "\n"))
		}

		resp.File = append(resp.File, &plugin_go.CodeGeneratorResponse_File{
			Name: proto.String(fileName),
			Content: proto.String(fmt.Sprintf(`%s

package %s
%s%s
`,
				FileHeader,
				filepath.Base(dirName),
				importString,
				buf.String(),
			)),
		})
	}

	for dirName := range dirs {
		pkgName := filepath.Base(dirName)
		resp.File = append(resp.File, &plugin_go.CodeGeneratorResponse_File{
			Name: proto.String(filepath.Join(dirName, fmt.Sprintf("%s.pb.util.fm.go", pkgName))),
			Content: proto.String(fmt.Sprintf(`%s

package %s

import (
	"sort"
	"strings"
)

// _cleanPaths cleans the given field mask paths. It returns a sorted slice of
// unique paths without any child paths that are already covered by parent paths.
func _cleanPaths(paths []string) []string {
	unique := make(map[string]struct{}, len(paths))
	for _, path := range paths {
		unique[path] = struct{}{}
	}
	for path := range unique {
		parts := strings.Split(path, ".")
		if len(parts) == 1 {
			continue
		}
		for i := 1; i < len(parts); i++ {
			if _, ok := unique[strings.Join(parts[:1], ".")]; ok {
				delete(unique, path)
			}
		}
	}

	out := make([]string, 0, len(unique))
	for path := range unique {
		out = append(out, path)
	}
	sort.Strings(out)
	return out
}

// _pathsWithoutPrefix returns the paths that contain the given prefix, but
// without that prefix.
func _pathsWithoutPrefix(prefix string, paths []string) []string {
	prefix += "."

	out := make([]string, 0, len(paths))
	for _, path := range paths {
		if !strings.HasPrefix(path, prefix) {
			continue
		}
		out = append(out, strings.TrimPrefix(path, prefix))
	}
	return out
}
`,
				FileHeader,
				pkgName,
			)),
		})
	}

	return resp, nil
}

func init() {
	log.SetFlags(0)
}

func main() {
	if err := protokit.RunPlugin(plugin{}); err != nil {
		log.Fatalf("Failed to run plugin: %s", err)
	}
}
